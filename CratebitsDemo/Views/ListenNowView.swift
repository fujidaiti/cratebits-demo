//
//  ListenNowView.swift
//  CratebitsDemo
//
//  Created by Claude on 2025/07/16.
//

import SwiftUI
import MusicKit

/// Listen NowÊ©üËÉΩ„ÅÆ„É°„Ç§„É≥„Éì„É•„Éº - TikTokÈ¢®„ÅÆÈü≥Ê•ΩÁô∫Ë¶ãUI
struct ListenNowView: View {
    @EnvironmentObject var storage: UserDefaultsStorage
    @EnvironmentObject var musicPlayer: MusicPlayerService
    @EnvironmentObject var toastManager: ToastManager
    @StateObject private var playlistGenerator = PlaylistGenerationService()
    @StateObject private var libraryService = AppleMusicLibraryService()
    @State private var currentIndex: Int? = 0
    
    var body: some View {
        NavigationView {
            ZStack {
                if storage.listenNowQueue.isEmpty {
                    emptyStateView
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    GeometryReader { geometry in
                        listenNowCarousel(geometry: geometry)
                    }
                    .ignoresSafeArea(.container, edges: .bottom)
                }
            }
            .navigationTitle("Listen Now")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .toolbar {
                #if os(iOS)
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("New Queue") {
                        generateNewQueue()
                    }
                }
                #else
                ToolbarItem(placement: .primaryAction) {
                    Button("New Queue") {
                        generateNewQueue()
                    }
                }
                #endif
            }
        }
#if os(iOS)
        .navigationViewStyle(.stack)
        #endif
        .onAppear {
            print("[ListenNow Debug] üöÄ View appeared with queue count: \(storage.listenNowQueue.count)")
            // Êó¢Â≠ò„ÅÆ„Ç≠„É•„Éº„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Ç≠„É£„ÉÉ„Ç∑„É•„Ç∑„Çπ„ÉÜ„É†„ÇíÂàùÊúüÂåñÔºà„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂÆüË°åÔºâ
            if !storage.listenNowQueue.isEmpty {
                print("[ListenNow Debug] üîÑ Initializing cache with existing queue")
                musicPlayer.updateListenNowItems(storage.listenNowQueue)
                print("[ListenNow Debug] üîÑ Cache initialization started in background")
            } else {
                print("[ListenNow Debug] üì≠ No existing queue found")
            }
        }
    }
    
    /// TikTokÈ¢®„ÅÆÊ•ΩÊõ≤„Ç´„É´„Éº„Çª„É´Ë°®Á§∫ÔºàÁ∏¶„Çπ„ÇØ„É≠„Éº„É´Ôºâ
    private func listenNowCarousel(geometry: GeometryProxy) -> some View {
        ScrollView(.vertical, showsIndicators: false) {
            VStack(spacing: 0) {
                ForEach(storage.listenNowQueue.indices, id: \.self) { index in
                    ListenNowCardView(
                        item: storage.listenNowQueue[index],
                        pageIndex: index,
                        onEvaluate: { evaluation in
                            handleEvaluation(evaluation, for: storage.listenNowQueue[index])
                        },
                        onPlay: {
                            playCurrentItem()
                        },
                        onPreview: { trackIndex in
                            playPreviewAndEnterMode(for: storage.listenNowQueue[index], trackIndex: trackIndex)
                        }
                    )
                    .frame(width: geometry.size.width, height: geometry.size.height)
                    .clipped()
                    .id(index)
                }
            }
        }
        .scrollTargetBehavior(.paging)
        .scrollPosition(id: $currentIndex)
        .onChange(of: currentIndex) { oldIndex, newIndex in
            print("[ListenNow Debug] üîÑ PAGE NAVIGATION: from \(String(describing: oldIndex)) to \(String(describing: newIndex))")
            
            guard let newIndex = newIndex, newIndex < storage.listenNowQueue.count else { 
                print("[ListenNow Debug] onChange: Invalid index - newIndex: \(String(describing: newIndex)), queue count: \(storage.listenNowQueue.count)")
                return 
            }
            
            let item = storage.listenNowQueue[newIndex]
            print("[ListenNow Debug] üìÑ NAVIGATED TO PAGE \(newIndex): '\(item.name)' (type: \(item.type))")
            if let appleMusicID = item.appleMusicID {
                print("[ListenNow Debug] üÜî Apple Music ID: \(appleMusicID)")
            }
            
            // Êñ∞„Åó„ÅÑ„Ç≠„É£„ÉÉ„Ç∑„É•„Ç∑„Çπ„ÉÜ„É†„Åß„Éï„Ç©„Éº„Ç´„ÇπÂ§âÊõ¥„ÇíÂá¶ÁêÜÔºà„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂÆüË°åÔºâ
            print("[ListenNow Debug] üéØ Calling handleFocusChange(to: \(newIndex))")
            musicPlayer.handleFocusChange(to: newIndex)
            print("[ListenNow Debug] üéØ handleFocusChange started in background")
            
            // „Éó„É¨„Éì„É•„Éº„É¢„Éº„Éâ‰∏≠„ÅØËá™Âãï„Åß„Éó„É¨„Éì„É•„Éº„ÇíÈñãÂßã
            if musicPlayer.isPreviewMode {
                print("[ListenNow Debug] üéß Preview mode active, starting preview for: \(item.name)")
                Task {
                    await musicPlayer.playPreviewInstantly(for: item)
                }
            }
        }
    }
    
    /// Á©∫Áä∂ÊÖã„ÅÆË°®Á§∫
    private var emptyStateView: some View {
        VStack(spacing: 20) {
            Image(systemName: "music.note")
                .font(.system(size: 80))
                .foregroundColor(.gray)
            
            Text("Listen Now")
                .font(.title)
                .fontWeight(.bold)
            
            Text("Add items to Listen Later to start discovering music")
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            
            if !storage.items.isEmpty {
                Button("Generate Queue") {
                    generateNewQueue()
                }
                .buttonStyle(.borderedProminent)
                .padding(.top)
            }
            
            // „Éó„É¨„Ç§„É§„ÉºÂà∂Âæ°ÔºàÂÜçÁîü‰∏≠„ÅÆÂ†¥Âêà„ÅÆ„ÅøË°®Á§∫Ôºâ
            if musicPlayer.isPlaying {
                playerControls
                    .padding(.top)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    /// „Éó„É¨„Ç§„É§„ÉºÂà∂Âæ°
    private var playerControls: some View {
        VStack {
            Text("Now Playing")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Text(musicPlayer.currentTrack ?? "Unknown")
                .font(.headline)
                .lineLimit(1)
            
            Text(musicPlayer.playbackStatus)
                .font(.caption)
                .foregroundColor(.secondary)
            
            HStack {
                Button(action: { Task { await musicPlayer.skipToPrevious() } }) {
                    Image(systemName: "backward.fill")
                }
                
                Button(action: { 
                    if musicPlayer.isPlaying {
                        musicPlayer.pause()
                    } else {
                        Task { await musicPlayer.resume() }
                    }
                }) {
                    Image(systemName: musicPlayer.isPlaying ? "pause.fill" : "play.fill")
                }
                
                Button(action: { Task { await musicPlayer.skipToNext() } }) {
                    Image(systemName: "forward.fill")
                }
                
                Button(action: { musicPlayer.stop() }) {
                    Image(systemName: "stop.fill")
                }
            }
            .buttonStyle(.borderless)
            .font(.title2)
        }
        .padding()
        .background(Color.secondary.opacity(0.1))
        .cornerRadius(10)
        .padding(.horizontal)
    }
    
    /// Êñ∞„Åó„ÅÑ„Ç≠„É•„Éº„ÇíÁîüÊàê
    private func generateNewQueue() {
        let randomItems = playlistGenerator.generateRandomListenNow(from: storage.items, count: 10)
        
        Task {
            let expandedTracks = await playlistGenerator.expandMixedItemsToTracks(randomItems)
            
            await MainActor.run {
                storage.saveListenNowQueue(expandedTracks)
                currentIndex = 0
                toastManager.show("üéµ New queue generated!", type: .success)
            }
            
            // Êñ∞„Åó„ÅÑ„Ç≠„É•„Éº„ÇíÈü≥Ê•Ω„Éó„É¨„Ç§„É§„Éº„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•„Ç∑„Çπ„ÉÜ„É†„Å´ÈÄöÁü•Ôºà„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂÆüË°åÔºâ
            print("[ListenNow Debug] üîÑ About to call updateListenNowItems with \(expandedTracks.count) items")
            musicPlayer.updateListenNowItems(expandedTracks)
            print("[ListenNow Debug] üîÑ updateListenNowItems started in background")
        }
    }
    
    /// ÁèæÂú®„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíÂÜçÁîü
    private func playCurrentItem() {
        guard let index = currentIndex, index < storage.listenNowQueue.count else { return }
        let item = storage.listenNowQueue[index]
        
        if item.type == .track, let appleMusicID = item.appleMusicID {
            Task {
                do {
                    let request = MusicCatalogResourceRequest<Song>(matching: \.id, equalTo: MusicItemID(appleMusicID))
                    let response = try await request.response()
                    
                    if let song = response.items.first {
                        await musicPlayer.playSong(song)
                        await MainActor.run {
                            toastManager.show("üéµ Now playing: \(song.title)", type: .success)
                        }
                    }
                } catch {
                    await MainActor.run {
                        toastManager.show("‚ùå Failed to play song", type: .error)
                    }
                    print("Error playing song: \(error)")
                }
            }
        } else {
            toastManager.show("‚ö†Ô∏è Full playback not implemented for \(item.type.displayName)", type: .warning)
        }
    }
    
    /// „Éó„É¨„Éì„É•„Éº„ÇíÈñãÂßã„Åó„Å¶„Éó„É¨„Éì„É•„Éº„É¢„Éº„Éâ„Å´ÂÖ•„Çã
    private func playPreviewAndEnterMode(for item: ListenLaterItem, trackIndex: Int?) {
        musicPlayer.enterPreviewMode()
        
        Task {
            // „Éî„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Éà„É©„ÉÉ„ÇØ„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºà„Ç¢„É´„Éê„É†„Éª„Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàÔºâ„ÅßtrackIndex„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åù„ÅÆ„Éà„É©„ÉÉ„ÇØ„ÇíÂÜçÁîü
            if let trackIndex = trackIndex,
               let pickedTracks = item.pickedTracks,
               trackIndex < pickedTracks.count {
                await musicPlayer.playPreviewInstantly(for: pickedTracks[trackIndex])
            } else {
                // Âçò‰∏Ä„Éà„É©„ÉÉ„ÇØ„Åæ„Åü„ÅØtrackIndex„ÅåÊú™ÊåáÂÆö„ÅÆÂ†¥Âêà„ÅØ„ÄÅÂÖÉ„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíÂÜçÁîü
                await musicPlayer.playPreviewInstantly(for: item)
            }
        }
    }
    
    /// „Ç¢„Ç§„ÉÜ„É†„ÅÆ„Éó„É¨„Éì„É•„Éº„ÇíÂÜçÁîü
    private func playPreview(for item: ListenLaterItem) {
        guard let appleMusicID = item.appleMusicID else { 
            toastManager.show("‚ùå No Apple Music ID available", type: .error)
            return 
        }
        
        Task {
            do {
                switch item.type {
                case .track:
                    let request = MusicCatalogResourceRequest<Song>(matching: \.id, equalTo: MusicItemID(appleMusicID))
                    let response = try await request.response()
                    
                    if let song = response.items.first {
                        await musicPlayer.playPreview(song)
                        await MainActor.run {
                            toastManager.show("üéß Preview playing", type: .info)
                        }
                    }
                    
                case .album, .artist:
                    // „Ç¢„É´„Éê„É†/„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„ÅÆÂ†¥Âêà„ÅØÊú™ÂÆüË£Ö
                    await MainActor.run {
                        toastManager.show("‚ö†Ô∏è Preview not implemented for \(item.type.displayName)", type: .warning)
                    }
                }
            } catch {
                await MainActor.run {
                    toastManager.show("‚ùå Failed to play preview", type: .error)
                }
                print("Error playing preview: \(error)")
            }
        }
    }
    
    /// Ë©ï‰æ°Âá¶ÁêÜ
    private func handleEvaluation(_ evaluation: EvaluationType, for item: ListenLaterItem) {
        // Ë©ï‰æ°„Çí„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
        let musicEvaluation = MusicEvaluation(
            itemId: item.id,
            evaluation: evaluation,
            dateEvaluated: Date()
        )
        storage.addEvaluation(musicEvaluation)
        
        // Ë©ï‰æ°„Å´Âøú„Åò„ÅüÂá¶ÁêÜ
        switch evaluation {
        case .like:
            // Like: Apple Music„É©„Ç§„Éñ„É©„É™„Å´‰øùÂ≠ò„Åó„Å¶Listen Later„Åã„ÇâÂâäÈô§
            Task {
                let success = await libraryService.addToLibrary(item)
                await MainActor.run {
                    if success {
                        storage.removeItem(id: item.id)
                        toastManager.show("üëç Added to Apple Music Library!", type: .success)
                    } else {
                        // macOS„Åß„ÅØÊ©üËÉΩ„ÅåÂà∂Èôê„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅListen Later„Åã„ÇâÂâäÈô§„ÅÆ„ÅøË°å„ÅÜ
                        #if os(macOS)
                        storage.removeItem(id: item.id)
                        toastManager.show("üëç Liked! (Library save not supported on macOS)", type: .info)
                        #else
                        toastManager.show("‚ùå Failed to add to library. Check Apple Music authorization.", type: .error)
                        #endif
                    }
                }
            }
            
        case .notForMe:
            // Not For Me: Listen Later„Åã„ÇâÂâäÈô§
            storage.removeItem(id: item.id)
            toastManager.show("üëé Removed from Listen Later", type: .success)
            
        case .listenAgainLater:
            // Listen Again Later: „Ç≠„É•„Éº„Åã„ÇâÂâäÈô§„ÅÆ„Åø
            toastManager.show("‚è∞ Added back to Listen Later", type: .info)
        }
        
        // Ê¨°„ÅÆ„Ç¢„Ç§„ÉÜ„É†„Å´ÁßªÂãï
        moveToNextItem()
    }
    
    /// Ê¨°„ÅÆ„Ç¢„Ç§„ÉÜ„É†„Å´ÁßªÂãï
    private func moveToNextItem() {
        guard let index = currentIndex else { return }
        if index < storage.listenNowQueue.count - 1 {
            currentIndex = index + 1
        } else {
            // „Ç≠„É•„Éº„ÅÆÊúÄÂæå„Å´Âà∞ÈÅî„Åó„Åü„Çâ„Éà„Éº„Çπ„Éà„ÅßÊ°àÂÜÖ
            toastManager.show("üîÑ End of queue. Tap 'New Queue' to generate more!", type: .info)
        }
    }
    
}


/// Listen Now„Ç´„Éº„ÉâË°®Á§∫„Éì„É•„Éº
struct ListenNowCardView: View {
    let item: ListenLaterItem
    let pageIndex: Int
    let onEvaluate: (EvaluationType) -> Void
    let onPlay: () -> Void
    let onPreview: (Int?) -> Void
    
    @EnvironmentObject var musicPlayer: MusicPlayerService
    @State private var currentTrackIndex = 0
    
    var body: some View {
        VStack(spacing: 0) {
            Spacer(minLength: 20)
            
            // „Ç¢„Ç§„ÉÜ„É†ÊÉÖÂ†±Ë°®Á§∫
            VStack(spacing: 16) {
                // „Çø„Ç§„Éó„Ç¢„Ç§„Ç≥„É≥
                Image(systemName: iconName)
                    .font(.system(size: 60))
                    .foregroundColor(iconColor)
                
                // „Çø„Ç§„Éà„É´
                Text(item.name)
                    .font(.title)
                    .fontWeight(.bold)
                    .multilineTextAlignment(.center)
                    .lineLimit(2)
                
                // „Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàÂêç
                Text(item.artist)
                    .font(.title2)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .lineLimit(1)
                
                // „Çø„Ç§„ÉóË°®Á§∫
                Text(item.type.displayName)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 4)
                    .background(Color.secondary.opacity(0.2))
                    .cornerRadius(8)
            }
            .padding(.horizontal, 40)
            
            Spacer(minLength: 20)
            
            // „Éî„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÊ•ΩÊõ≤„Ç´„É´„Éº„Çª„É´Ôºà„Ç¢„É´„Éê„É†/„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„ÅÆÂ†¥Âêà„ÅÆ„ÅøÔºâ
            if let pickedTracks = item.pickedTracks, !pickedTracks.isEmpty {
                VStack(spacing: 12) {
                    Text("Picked Tracks")
                        .font(.headline)
                        .foregroundColor(.secondary)
                        .padding(.horizontal, 20)  // „Çø„Ç§„Éà„É´„ÅÆ„Åø„Å´„Éë„Éá„Ç£„É≥„Ç∞
                    
                    TrackCarouselView(
                        tracks: pickedTracks,
                        currentIndex: $currentTrackIndex,
                        onTrackPreview: { track in
                            // „Éó„É¨„Éì„É•„Éº„É¢„Éº„Éâ‰∏≠„ÅØËá™ÂãïÁöÑ„Å´„Éî„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÊ•ΩÊõ≤„ÅÆ„Éó„É¨„Éì„É•„Éº„ÇíÂÜçÁîü
                            if musicPlayer.isPreviewMode {
                                Task {
                                    await musicPlayer.playPreviewInstantly(for: track)
                                }
                            }
                        },
                        onCarouselIndexChange: { trackIndex in
                            // „Ç´„É´„Éº„Çª„É´ÂÜÖÁßªÂãïÊôÇ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•Âá¶ÁêÜÔºà„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂÆüË°åÔºâ
                            musicPlayer.handleCarouselFocusChange(to: pageIndex, trackIndex: trackIndex)
                        }
                    )
                    .frame(height: 120)
                }
                .padding(.bottom, 20)
            }
            
            Spacer(minLength: 20)
            
            // ÂÜçÁîü„Éú„Çø„É≥
            HStack(spacing: 20) {
                Button(action: { 
                    // „Éî„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Éà„É©„ÉÉ„ÇØ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÁèæÂú®„ÅÆ„Éà„É©„ÉÉ„ÇØ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÊ∏°„Åô
                    if item.pickedTracks != nil {
                        onPreview(currentTrackIndex)
                    } else {
                        onPreview(nil)
                    }
                }) {
                    HStack {
                        Image(systemName: "play.circle")
                        Text("Preview")
                    }
                    .font(.title2)
                    .foregroundColor(.white)
                    .padding(.horizontal, 20)
                    .padding(.vertical, 12)
                    .background(Color.orange)
                    .cornerRadius(25)
                }
                
                Button(action: onPlay) {
                    HStack {
                        Image(systemName: "play.fill")
                        Text("Play")
                    }
                    .font(.title2)
                    .foregroundColor(.white)
                    .padding(.horizontal, 20)
                    .padding(.vertical, 12)
                    .background(Color.blue)
                    .cornerRadius(25)
                }
            }
            .padding(.bottom, 20)
            
            // „Éó„É¨„Éì„É•„ÉºÁä∂ÊÖãË°®Á§∫
            PreviewStatusView()
                .padding(.bottom, 10)
            
            // Ë©ï‰æ°„Éú„Çø„É≥
            HStack(spacing: 40) {
                ForEach(EvaluationType.allCases, id: \.self) { evaluation in
                    Button(action: {
                        onEvaluate(evaluation)
                    }) {
                        VStack {
                            Image(systemName: evaluation.systemImage)
                                .font(.title)
                            Text(evaluation.displayName)
                                .font(.caption)
                        }
                        .foregroundColor(evaluation.color)
                    }
                }
            }
            .padding(.bottom, 60) // „Çø„Éñ„Éê„Éº„ÅÆ„Çπ„Éö„Éº„Çπ„ÇíÁ¢∫‰øù
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            LinearGradient(
                colors: [Color.clear, iconColor.opacity(0.1)],
                startPoint: .top,
                endPoint: .bottom
            )
        )
    }
    
    private var iconName: String {
        switch item.type {
        case .track: return "music.note"
        case .album: return "square.stack"
        case .artist: return "person.circle"
        }
    }
    
    private var iconColor: Color {
        switch item.type {
        case .track: return .blue
        case .album: return .green
        case .artist: return .purple
        }
    }
}

/// „Éó„É¨„Éì„É•„ÉºÁä∂ÊÖãË°®Á§∫„Éì„É•„Éº
struct PreviewStatusView: View {
    @EnvironmentObject var musicPlayer: MusicPlayerService
    @EnvironmentObject var toastManager: ToastManager
    
    var body: some View {
        if musicPlayer.isPreviewMode {
            VStack(spacing: 8) {
                HStack {
                    Image(systemName: "timer")
                        .foregroundColor(.orange)
                    Text("Preview Mode")
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(.orange)
                }
                
                Text("\(musicPlayer.previewTimeRemaining)s remaining")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                HStack {
                    Button("Stop Preview") {
                        musicPlayer.stopPreview()
                        toastManager.show("‚èπÔ∏è Preview stopped", type: .info)
                    }
                    .font(.caption)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 4)
                    .background(Color.orange.opacity(0.2))
                    .foregroundColor(.orange)
                    .cornerRadius(8)
                    
                    Button("Exit Preview Mode") {
                        musicPlayer.exitPreviewMode()
                        toastManager.show("üö™ Exited preview mode", type: .info)
                    }
                    .font(.caption)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 4)
                    .background(Color.red.opacity(0.2))
                    .foregroundColor(.red)
                    .cornerRadius(8)
                }
            }
        }
    }
}

/// Ê•ΩÊõ≤„ÅÆÊ®™„Çπ„ÇØ„É≠„Éº„É´„Ç´„É´„Éº„Çª„É´„Éì„É•„Éº
struct TrackCarouselView: View {
    let tracks: [ListenLaterItem]
    @Binding var currentIndex: Int
    let onTrackPreview: (ListenLaterItem) -> Void
    let onCarouselIndexChange: ((Int) -> Void)? // „Ç´„É´„Éº„Çª„É´„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÂ§âÊõ¥ÊôÇ„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÔºà„Ç™„Éó„Ç∑„Éß„Éä„É´Ôºâ
    
    @EnvironmentObject var musicPlayer: MusicPlayerService
    @State private var scrolledID: Int?
    @State private var debounceTask: Task<Void, Never>?
    
    var body: some View {
        GeometryReader { geometry in
            let screenWidth = geometry.size.width
            let cardWidth = screenWidth * 0.6  // „Ç´„Éº„ÉâÂπÖ„ÇíÂ∞ë„ÅóÂ∞è„Åï„Åè
            let spacing: CGFloat = 20
            let sideInset = (screenWidth - cardWidth) / 2  // Èö£Êé•„Ç´„Éº„Éâ„ÅåË¶ã„Åà„Çã„Åü„ÇÅ„ÅÆ„Ç§„É≥„Çª„ÉÉ„Éà
            
            ScrollViewReader { proxy in
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: spacing) {
                        ForEach(tracks.indices, id: \.self) { index in
                            TrackCardView(
                                track: tracks[index]
                            )
                            .frame(width: cardWidth)
                            .id(index)
                        }
                    }
                    .padding(.horizontal, sideInset)  // Â∑¶Âè≥„Å´„Éë„Éá„Ç£„É≥„Ç∞„ÇíËøΩÂä†
                    .scrollTargetLayout()
                }
                .scrollTargetBehavior(.viewAligned)
                .scrollPosition(id: $scrolledID)
                .onChange(of: scrolledID) { _, newID in
                    guard let newID = newID, newID < tracks.count else { return }
                    
                    print("[Carousel Debug] ScrolledID changed to: \(newID)")
                    
                    // currentIndex„ÇíÂç≥Â∫ß„Å´Êõ¥Êñ∞ÔºàUIÂøúÁ≠îÊÄß„ÅÆ„Åü„ÇÅÔºâ
                    currentIndex = newID
                    
                    // „Éó„É¨„Éì„É•„Éº„É¢„Éº„Éâ‰∏≠„ÅØ„Éá„Éê„Ç¶„É≥„ÇπÂá¶ÁêÜ„Åß„Éó„É¨„Éì„É•„Éº„ÇíÂàá„ÇäÊõø„Åà
                    if musicPlayer.isPreviewMode {
                        // Ââç„ÅÆ„Çø„Çπ„ÇØ„Çí„Ç≠„É£„É≥„Çª„É´
                        debounceTask?.cancel()
                        
                        // Êñ∞„Åó„ÅÑ„Éá„Éê„Ç¶„É≥„Çπ„Çø„Çπ„ÇØ„ÇíÈñãÂßã
                        debounceTask = Task {
                            do {
                                try await Task.sleep(nanoseconds: 300_000_000) // 300msÂæÖÊ©ü
                                
                                if !Task.isCancelled {
                                    print("[Carousel Debug] Debounced: Auto-switching preview to track: \(tracks[newID].name)")
                                    onTrackPreview(tracks[newID])
                                    
                                    print("[Carousel Debug] Debounced: Notifying parent of carousel index change: \(newID)")
                                    onCarouselIndexChange?(newID)
                                }
                            } catch {
                                // Task.sleep „Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„ÅüÂ†¥Âêà
                                print("[Carousel Debug] Debounce task cancelled")
                            }
                        }
                    }
                }
                .onAppear {
                    // ÂàùÊúüË°®Á§∫ÊôÇ„ÅÆscrolledID„ÇíË®≠ÂÆö
                    scrolledID = currentIndex
                    // ÂàùÊúüË°®Á§∫ÊôÇ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•„Å®„Éó„É¨„Éì„É•„Éº
                    setupInitialState()
                }
                .onDisappear {
                    // „Éì„É•„Éº„ÅåÊ∂à„Åà„ÇãÊôÇ„Å´„Éá„Éê„Ç¶„É≥„Çπ„Çø„Çπ„ÇØ„Çí„Ç≠„É£„É≥„Çª„É´
                    debounceTask?.cancel()
                }
            }
        }
    }
    
    
    
    /// ÂàùÊúüÁä∂ÊÖã„ÅÆ„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
    private func setupInitialState() {
        // „Éó„É¨„Éì„É•„Éº„É¢„Éº„Éâ‰∏≠„ÅÆÂ†¥Âêà„ÄÅÁèæÂú®„ÅÆ„Éà„É©„ÉÉ„ÇØ„ÅÆ„Éó„É¨„Éì„É•„Éº„ÇíÈñãÂßã
        if musicPlayer.isPreviewMode && currentIndex < tracks.count {
            print("[Carousel Debug] Initial preview for track: \(tracks[currentIndex].name)")
            onTrackPreview(tracks[currentIndex])
            // „Éó„É¨„Éì„É•„Éº„É¢„Éº„Éâ‰∏≠„ÅÆÂ†¥Âêà„ÅÆ„Åø„Ç≠„É£„ÉÉ„Ç∑„É•Âá¶ÁêÜ„ÇíÈÄöÁü•
            onCarouselIndexChange?(currentIndex)
        }
    }
}

/// ÂÄãÂà•Ê•ΩÊõ≤„Ç´„Éº„Éâ„Éì„É•„Éº
struct TrackCardView: View {
    let track: ListenLaterItem
    
    var body: some View {
        VStack {
            // Ê•ΩÊõ≤„Çø„Ç§„Éà„É´„ÅÆ„ÅøË°®Á§∫
            Text(track.name)
                .font(.body)
                .fontWeight(.medium)
                .lineLimit(3)
                .multilineTextAlignment(.center)
                .foregroundColor(.primary)
                .frame(maxWidth: .infinity, minHeight: 60)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 20)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.gray.opacity(0.05))
        )
    }
}

#Preview {
    ListenNowView()
        .environmentObject(UserDefaultsStorage())
        .environmentObject(MusicPlayerService())
        .environmentObject(ToastManager())
}